# Inventory Management App (PostgreSQL + PostgREST + Flask + pywebview)

## Goal
Develop a desktop-first inventory management app that:
- Tracks products across multiple warehouses.
- Provides a dashboard for stock status, reservations, and purchasing needs.
- Integrates with a client-facing webstore via API.
- Starts small (MVP) and can gradually scale to a full-featured inventory & purchasing system.

---

## Architecture

### Database
- **PostgreSQL**
  - Central relational store.
  - Schema-first design (products, warehouses, stock, orders, reservations).
  - Use constraints & triggers to enforce stock integrity.
  - Migrations managed with Alembic/Flyway.

### API
- **PostgREST**
  - Auto-generates REST API from PostgreSQL schema.
  - Exposes CRUD + RPC endpoints.
  - Row-level security (RLS) for safe multi-role access.
  - Business rules implemented in Postgres functions where possible.

### Backend / UI Server
- **Flask**
  - Handles authentication & session management (Flask-Login).
  - Provides Jinja2/WTForms-based forms and dashboard templates.
  - Optionally proxies API requests to PostgREST (for validation, additional business logic).
  - Can directly query Postgres (via psycopg2) for special cases.

### Desktop Client
- **pywebview**
  - Wraps Flask UI into a native desktop window.
  - Provides a lightweight, Electron-like experience.
- **cefpython3** (optional alternative)
  - If you need a Chromium engine instead of system webview.
- Distribution: packaged with PyInstaller or Briefcase for cross-platform executables.

---

## Phase Plan

### Phase 1 (MVP)
- Database schema:
  - Products (SKU, description, dimensions, picture, barcode).
  - Warehouses & locations (aisle/bin).
  - Stock items (available, reserved).
- PostgREST serving `/products`, `/stock`, `/warehouses`.
- Flask desktop client:
  - Login screen (Flask-Login).
  - Product lookup + details.
  - Stock overview dashboard.

### Phase 2
- Orders & reservations linked to stock.
- Dashboard alerts for low stock.
- CRUD forms for products and stock via Flask/WTForms.
- API endpoints exposed to client-facing webstore.

### Phase 3
- Supplier management & purchase order tracking.
- Role-based access (warehouse staff, manager, admin).
- Audit trail of all stock movements.

### Phase 4
- Analytics & forecasting dashboards (pandas + plotly).
- Mobile/tablet support (Flask served externally).
- ERP/CRM integration.

---

## Database Model (Initial Proposal)

- **Products**: id, sku, name, description, dimensions, weight, picture_url, barcode.
- **Warehouses**: id, name, address.
- **Locations**: id, warehouse_id, aisle, bin.
- **StockItems**: id, product_id, location_id, qty_available, qty_reserved.
- **Orders**: id, client_id, status, created_at.
- **Reservations**: id, order_id, product_id, qty, status.
- **Users**: id, username, password_hash, role.

---

## Starter PostgreSQL Schema

```sql
-- Enable useful extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Users (for app authentication and role management)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('admin', 'manager', 'worker')),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Products
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sku TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    dimensions TEXT,
    weight NUMERIC,
    picture_url TEXT,
    barcode TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Warehouses
CREATE TABLE warehouses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    address TEXT
);

-- Locations inside warehouses
CREATE TABLE locations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    warehouse_id UUID REFERENCES warehouses(id) ON DELETE CASCADE,
    aisle TEXT NOT NULL,
    bin TEXT NOT NULL,
    UNIQUE (warehouse_id, aisle, bin)
);

-- Stock items
CREATE TABLE stock_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    location_id UUID REFERENCES locations(id) ON DELETE CASCADE,
    qty_available INT NOT NULL DEFAULT 0,
    qty_reserved INT NOT NULL DEFAULT 0,
    CHECK (qty_available >= 0),
    CHECK (qty_reserved >= 0)
);

-- Orders
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    client_id UUID,
    status TEXT NOT NULL CHECK (status IN ('open', 'fulfilled', 'cancelled')),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Reservations (link orders to stock)
CREATE TABLE reservations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    qty INT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('reserved', 'picked', 'cancelled')),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Example function for moving stock
CREATE OR REPLACE FUNCTION move_stock(
    p_stock_id UUID,
    p_new_location UUID,
    p_qty INT
) RETURNS VOID AS $$
BEGIN
    UPDATE stock_items
    SET qty_available = qty_available - p_qty
    WHERE id = p_stock_id AND qty_available >= p_qty;

    INSERT INTO stock_items (product_id, location_id, qty_available, qty_reserved)
    SELECT product_id, p_new_location, p_qty, 0
    FROM stock_items
    WHERE id = p_stock_id;
END;
$$ LANGUAGE plpgsql;

